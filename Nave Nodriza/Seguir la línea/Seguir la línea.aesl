<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<constant value="100" name="SIGMA"/>
<constant value="4000" name="UMB_OBST"/>
<constant value="200" name="VEL"/>


<!--node Explorador1 en Lidi - 9600-->
<node nodeId="{0dd3658f-e8e1-4a58-8c50-8f3b08fee791}" name="Explorador1 en Lidi - 9600"><![CDATA[var left
var right
var mini = 1024
var maxi = 0
var mean = 512
var vari = 512
var p1
var ndev
var ireg = 0
var preg
var pcoeff = 60
var icoeff = 33
var exploring = 1  # 1 para exploración, 0 para seguimiento de línea
var random_turn =0  # 
timer.period[0]=1000
# Evento de proximidad
onevent prox
call leds.top(32,32,32)
	if    prox.horizontal[3]> UMB_OBST then
		call leds.top(32,0,0)
		motor.left.target = -VEL
   		motor.right.target = -VEL
   		
	# Revisamos si hay un obstaculo detras (sensor 5 y 6)
  	elseif prox.horizontal[5] > UMB_OBST or prox.horizontal[6] > UMB_OBST then
  		call leds.top(32,0,0)
    	# Nos alejamos de el avanzando hacia adelante (ambos positivos)
    	motor.left.target = VEL
   		motor.right.target = VEL
    
  	# Revisamos si hay un obstaculo a la derecha (sensor 3 y 4)
 	elseif prox.horizontal[3] > UMB_OBST or prox.horizontal[4] > UMB_OBST then
 		call leds.top(32,0,0)
    	# Nos alejamos de el girando a la izquierda (izq negativo y der positivo)
   		 motor.left.target = -500
   		 motor.right.target = VEL
    
  	# Revisamos si hay un obstaculo a la izquierda (sensor 0 y 1)
  	elseif prox.horizontal[1] > UMB_OBST or prox.horizontal[0]> UMB_OBST then
  		call leds.top(32,0,0)
    	# Nos alejamos de el girando a la derecha (izq positivo y der negativo)
    	motor.left.target = VEL
    	motor.right.target = -500
    	
    #Sino hay obstáculos
	else
	 #Y estamos explorando
	  if exploring == 1 then
	  	call leds.top(32,32,32)
	    callsub explore
	  
	  #Si no estamos explorando
	  else  
		    p1 = prox.ground.delta[1]
		    callsub statistics
		    call math.muldiv(ndev, SIGMA, p1 - mean, vari)
		    if abs(ndev) < SIGMA then
			      call leds.top(0,32,0)
			      preg = (pcoeff * ndev) / 100
			      ireg += (icoeff * preg) / 100
			      left = VEL + (preg + ireg)
			      right = VEL - (preg + ireg)
			 else
			      call leds.top(0, 0, 32)
			      ireg = 0
			      left = ndev
			      right = -ndev
			 end
		    callsub set_motor
	  end
  
	  # Si detecta una línea, cambia a modo de seguimiento
	  if  prox.ground.delta[0] < mean - SIGMA or prox.ground.delta[1] < mean - SIGMA then
	    exploring = 0
	  else
	    # Si no detecta una línea durante el seguimiento, vuelve a explorar
	    if exploring == 0 and abs(ndev) >= SIGMA then
	      exploring = 1
	  end
	  
  end
end

sub statistics
	  call math.max(maxi, maxi, p1)
	  call math.min(mini, mini, p1)
	  if maxi - mini > 400 then
	    call math.muldiv(vari, 45, maxi - mini, 100)
	    mean = (mini + maxi) / 2
	  end

sub set_motor
	  motor.left.target = left
	  motor.right.target = right

sub explore
	  # Exploración aleatoria
	 
	  if random_turn >0 then
	    left = VEL
	    right = VEL / 2  # Gira a la derecha
	  else
	    left = VEL / 2
	    right = VEL  # Gira a la izquierda
	  end
	  callsub set_motor

onevent timer0
	 call math.rand(random_turn)
  

]]></node>


</network>
